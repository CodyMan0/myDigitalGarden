{
  "last_modified_at": "17-Jan-23",
  "title": "Advantage of js",
  "backlinks": [
    "<html><body>\n<h1 id=\"특징\">특징</h1>\n<p>몽키 패치 (monkey patch )\n런타임 중인 프로그램의 내용이 변경되는 행동을 의미한다. -&gt; 안티 패턴</p>\n\n<p>문법은 Java\n문자열, 배열, 정규 표현식 : Pearl\n함수 : 오크\n클로저, 스코프 : 스키마\n프로토타입 : 셀프\n이벤트 : 하이퍼토크</p>\n\n<ol>\n  <li>언어자체가 굉장히 자유롭다..</li>\n</ol>\n\n<p><a class=\"internal-link\" href=\"/advantage-of-js\">Advantage of JS</a></p>\n</body></html>",
    "<html><body>\n<p><a href=\"https://www.frontendinterviewhandbook.com/kr/javascript-questions#single-page-app%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%98%EA%B3%A0-seo-friendly%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94\" target=\"_blank\">handBook</a></p>\n\n<h1 id=\"프로그래밍-언어-중-하나\">프로그래밍 언어 중 하나</h1>\n<h2 id=\"정의\">정의</h2>\n<p><a class=\"internal-link\" href=\"/js-definition\">JS_Definition</a></p>\n<h2 id=\"특징\">특징</h2>\n<p><a class=\"internal-link\" href=\"/js-feature\">JS_Feature</a></p>\n<h2 id=\"장단점\">장단점</h2>\n<p><a class=\"internal-link\" href=\"/advantage-of-js\">Advantage of JS</a>\n<a class=\"internal-link\" href=\"/limitation-of-js\">limitation of JS</a></p>\n<h2 id=\"동작-원리\">동작 원리</h2>\n<p><a class=\"internal-link\" href=\"/js-working-principle\">JS_Working_Principle</a></p>\n<h2 id=\"디테일한-문법\">디테일한 문법</h2>\n<p><a class=\"internal-link\" href=\"/js-syntax\">JS_Syntax</a>\n<a class=\"internal-link\" href=\"/js-data-type\">JS_data_type</a>\n<a class=\"internal-link\" href=\"/js-method\">JS_method</a></p>\n\n<h2 id=\"furthurmore\">furthurMore</h2>\n<p><a class=\"internal-link\" href=\"/js-system-call\">JS_system_call</a></p>\n\n<h3 id=\"for-문\">for 문</h3>\n<ol>\n  <li><a class=\"internal-link\" href=\"/for-of\">for of</a></li>\n</ol>\n\n</body></html>",
    "<html><body>\n<p>적</p>\n<h1 id=\"개념-잡기-키워드\">개념 잡기 키워드</h1>\n<p>#Q 1. 할당 가능 검사 !== 잉여 속성 체크. 를 알아야한다.\n-&gt;</p>\n\n<h2 id=\"아하-포인트\">아하 포인트</h2>\n<p><strong>타입스크립트에서는 함수 표현식을 사용하는 것이 좋다.</strong></p>\n\n<p><strong>1/6 (금)</strong></p>\n<h3 id=\"편집기-활용해서-타입시스템-확인하기\">편집기 활용해서 타입시스템 확인하기</h3>\n\n<ul>\n  <li>fetch의 정의\n    <div class=\"language-ts highlighter-rouge\">\n<div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">declare</span> <span class=\"kd\">function</span> <span class=\"nx\">fetch</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">:</span> <span class=\"nx\">RequestInfo</span> <span class=\"o\">|</span> <span class=\"nx\">URL</span><span class=\"p\">,</span> <span class=\"nx\">init</span><span class=\"p\">?:</span> <span class=\"nx\">RequestInit</span><span class=\"p\">):</span> <span class=\"nb\">Promise</span><span class=\"o\">&lt;</span><span class=\"nx\">Response</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n\n<p>참고 <a class=\"internal-link\" href=\"/promise-js\">Promise (js)</a></p>\n\n<p>-&gt; 타입을 편집기에서 정의로 이동하기를 통해 찾아보는 것을 추천</p>\n\n<h3 id=\"타입이-값들의-집합이라고-생각하기\">타입이 값들의 집합이라고 생각하기</h3>\n<p>지난번에 “타입은 값이다”가 햇갈렸는데 너 잘 만났다.</p>\n\n<p>런타임 동안 <strong>변수는 값</strong>이 할당된다.\n컴파일때는 <strong>할당 가능한 값들의 집합</strong>(TYPE의 범위)이 존재</p>\n\n<p>-&gt; 다른 팀원들\n집합으로 이해하기?</p>\n\n<p>타입 체커 이해하기 (집합 관점)</p>\n<ol>\n  <li>\n<a class=\"internal-link\" href=\"/type-never\">type_never</a> (공집합)</li>\n  <li>한가지만 포함하는 타입 : 유닛타입의 리터럴</li>\n  <li>유니온 타입 ( “ | “)(합집합)\n–&gt; 타입 체커는 집합의 관점에서 생각해보면 이해가 간다\n==4. &amp; 연산자  (교집합)\n–&gt; (“  &amp;  “)==</li>\n</ol>\n\n<p>#Q 왜 의미하는거지? \n-&gt; A,b를가지고 있는 abc를 가지고 있어도 된다. 오류를 안잡는다. 필수 조건만 만족해라. -&gt; 추상화와 관련 지난번</p>\n\n<p><span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  구조적 타이핑  <span class=\"invalid-link-brackets\">]]</span></span> 규칙들은 어떠한 값이 다른 속성도 가질 수 있다는 것을 의미</p>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">interface</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n<span class=\"nl\">name</span> <span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">interface</span> <span class=\"nx\">Lifespan</span> <span class=\"p\">{</span>\n<span class=\"nl\">birth</span> <span class=\"p\">:</span> <span class=\"nb\">Date</span><span class=\"p\">;</span>\n<span class=\"nl\">death</span><span class=\"p\">?</span> <span class=\"p\">:</span> <span class=\"nb\">Date</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">type</span> <span class=\"nx\">PersonSpan</span> <span class=\"o\">=</span>  <span class=\"nx\">Person</span> <span class=\"o\">&amp;</span> <span class=\"nx\">Lifespan</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<p>두 interface의 교집합이 없어서 never 같으나 타입 연산자는 인터페이스 속성이 아닌 타입의 범위 (컴파일때 할당 가능한 값들의 집합)에 적용되기에 Person, Lifesapn을 둘다 가지는 값은 인터섹션 타입에 속한다. (팀원들의 설명을 참고해서 이해해야겠다 )</p>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">ps</span><span class=\"p\">:</span><span class=\"nx\">PersonSpan</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"na\">name</span> <span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">ju young</span><span class=\"dl\">'</span><span class=\"p\">,</span>\n<span class=\"na\">birth</span> <span class=\"p\">:</span> <span class=\"k\">new</span> <span class=\"nb\">Date</span> <span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">1996/07/10</span><span class=\"dl\">'</span><span class=\"p\">)</span>\n<span class=\"na\">death</span> <span class=\"p\">:</span> <span class=\"k\">new</span> <span class=\"nb\">Date</span> <span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">2088/07/10</span><span class=\"dl\">'</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>-&gt;&amp; 말고 extends를 사용하면 더 일반적이다.</p>\n\n<ul>\n  <li>배열과 튜플 타입 ‘\n    <div class=\"language-ts highlighter-rouge\">\n<div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n<span class=\"kd\">const</span> <span class=\"nx\">tuple</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"kr\">number</span><span class=\"p\">,</span> <span class=\"kr\">number</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">list</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n\n<p>관련있는 메모 : <a class=\"internal-link\" href=\"/usestate\">useState</a></p>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">useState</span><span class=\"o\">&lt;</span><span class=\"nx\">S</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">initialState</span><span class=\"p\">:</span> <span class=\"nx\">S</span> <span class=\"o\">|</span> <span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">S</span><span class=\"p\">)):</span> <span class=\"p\">[</span><span class=\"nx\">S</span><span class=\"p\">,</span> <span class=\"nx\">Dispatch</span><span class=\"o\">&lt;</span><span class=\"nx\">SetStateAction</span><span class=\"o\">&lt;</span><span class=\"nx\">S</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">];</span>\n</code></pre></div></div>\n\n<p><a class=\"internal-link\" href=\"/tuple\">tuple</a></p>\n\n<p>타입 요약 정리 \n!<span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  스크린샷 2023-01-06 오후 4.03.00.png  <span class=\"invalid-link-brackets\">]]</span></span></p>\n\n<h3 id=\"타입-공간과-값-공간의-심벌-구하기\">타입 공간과 값 공간의 심벌 구하기</h3>\n<p>타입 스크립트의 Symbol은 타입 공간이나 값 공간 중의 한곳에 존재한다라………\n우선 패쓰 \n여기서 말하는 심볼이 자바스크립트 심볼을 말하는건가?</p>\n\n<h4 id=\"흩어진-지식-모음\">흩어진 지식 모음</h4>\n\n<ol>\n  <li>동일한 이름의 심볼과 값\n    <ul>\n      <li>똑같은 이름 하나는 타입 함수</li>\n      <li>instanceOf 는 런타임 연산자 <mark>= 값에 대한 연산을 한다는 것 </mark> 타입은 런타임에는 없다.  함수를 참조하는 것.</li>\n    </ul>\n  </li>\n  <li>식별자에 따른 심볼과 값\n    <ul>\n      <li>type , interface 뒤에는 심볼</li>\n      <li>const, let 뒤에는 값</li>\n    </ul>\n  </li>\n  <li>타입과 값 두 가지 모두 가능한 예약어\n    <ul>\n      <li>\n<a class=\"internal-link\" href=\"/class\">class</a> 와 <a class=\"internal-link\" href=\"/enum\">enum</a>\n</li>\n    </ul>\n  </li>\n</ol>\n\n<p>!<span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  스크린샷 2023-01-07 오후 12.27.53.png  <span class=\"invalid-link-brackets\">]]</span></span></p>\n\n<p>값으로 쓰일때는 constructor가 생긴다.</p>\n\n<p>타입일때와 값일떄 다르게 동작하는 애들 \n| 요소    | JS  | TS  |\n| ——- | — | — |\n| typeof  |     |     |\n| this    |     |  subClass의 메서드 체인을 구현할떄 유용   |\n| &amp; , 1   |  AND OR   |  교집합, 합집합 타입 체커   |\n| const   |  변수 선언   |  as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다.   |\n| extends |  하위클레스에 사용   |  클래스 타입 제네릭 타입의 한정자를 정의 할 수 있다…    |\n| in      |  for문에서 봤음   |  매핑된 타입에서 볼 수 있다.    |</p>\n\n<ul>\n  <li>타입스크립트 코드에서는 <strong>타입의 공간</strong>과 <strong>값 공간</strong>을 혼동하기 쉬움 \n#Q 컴파일과 런타임인가? \n컴파일 -&gt; 타입체커 \n런타임 -&gt; 값</li>\n</ul>\n\n<p>-&gt; 코드 작성시에는 코드와 값을 같이 쓰기에 혼동하기 쉬움 instanceof 예시!</p>\n\n<p>예시 ) 구조분해할당</p>\n<div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">email</span> <span class=\"p\">(</span><span class=\"nx\">option</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"nl\">person</span> <span class=\"p\">:</span> <span class=\"nx\">Person</span> <span class=\"p\">...}){</span>\n<span class=\"c1\">// ...</span>\n\n<span class=\"p\">}</span>\n\n\n<span class=\"kd\">function</span> <span class=\"nx\">email</span> <span class=\"p\">({</span><span class=\"na\">person</span> <span class=\"p\">:</span> <span class=\"nx\">Person</span> <span class=\"p\">...}){</span>\n<span class=\"c1\">// ...</span>\n\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">email</span> <span class=\"p\">({</span>\n<span class=\"na\">person</span> <span class=\"p\">:</span> <span class=\"nx\">Person</span>\n<span class=\"c1\">// 바인딩 요소 \"Person\"에 암시적으로 any가 할당</span>\n<span class=\"p\">...}){</span>\n<span class=\"c1\">// ...</span>\n\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>값의 관점에서 Person과 string이 해석되어서 라는데??? \n와닿지는 않음 음</p>\n\n<p>-&gt;</p>\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">email</span> <span class=\"p\">({</span>\n<span class=\"nx\">person</span><span class=\"p\">...}:</span> <span class=\"p\">{</span><span class=\"nl\">person</span> <span class=\"p\">:</span> <span class=\"nx\">Person</span><span class=\"p\">,</span> <span class=\"p\">...}){</span>\n<span class=\"c1\">// ...</span>\n\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>타입과 값을 구분!!</p>\n\n<p>코드를 읽을때 타입인지값인지 구분하면서 코드를 작성해야한다.</p>\n\n<p>what is ?\n-&gt;   TypeScript is <strong>a strongly typed programming language that builds on JavaScript</strong></p>\n\n<p>how to use ? \n-&gt; typescript are annotated using <code class=\"language-plaintext highlighter-rouge\">:TypeAnnotation</code> syntax</p>\n\n<p>what do i decide ? \n-&gt; after today’s contents</p>\n\n<p>what do i have not to use? \n-&gt; after today’s contents</p>\n\n<h3 id=\"타입-단언보다-선언하기\">타입 단언보다 선언하기</h3>\n<p>잉여속성체크가 되지 않기 때문에 \n#흩어진지식 또한 타입 단언문을 사용할때에도 적용되지 않는다.</p>\n\n<p>1/10</p>\n\n<p><strong>1/10 (화)</strong></p>\n<h3 id=\"객체-래퍼-타입-피하기\">객체 래퍼 타입 피하기</h3>\n\n<p>자바스크립트 불변형 7가지\n기본형은 메소드가 없는 특징을 가지고 있는데 \n어떻게 string은 매소드가 있는거지?</p>\n\n<p><strong>자바스크립트에서 string에는 객체 메소드가 타입으로 정의 되어있다.</strong> \n<strong>-&gt; 타입스크립트도 동일하다</strong></p>\n\n<p>다른 기본형에서 객체 래퍼 존재!\nnumber -&gt; Number\n… 등등\n!! 아하 Number이 객체 래퍼였구나? 그러니깐 매소드를 쓸 수 있는거였네</p>\n\n<p><strong>타입스크립트에서도 기본형과 객체 래퍼 타입을 별도로 지정한다.</strong>\n!<span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  스크린샷 2023-01-10 오후 12.28.55.png  <span class=\"invalid-link-brackets\">]]</span></span></p>\n<h4 id=\"결론\">결론</h4>\n<p><strong>오타 조심해라!</strong> 기본형과 타입형 타입이 다르게 선언되어있다.\n객체 래퍼 타입을 사용할 필요가 없고 기본형 사용하면 된다.</p>\n\n<h3 id=\"잉여-속성-체크의-한계-인지하기\">잉여 속성 체크의 한계 인지하기</h3>\n<div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">interface</span> <span class=\"nx\">Room</span> <span class=\"p\">{</span>\n\n\t<span class=\"nl\">num</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">;</span>\n\n\t<span class=\"nl\">ceil</span><span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">;</span>\n\n<span class=\"p\">}</span>\n\n  \n\n<span class=\"kd\">const</span> <span class=\"nx\">r</span> <span class=\"p\">:</span> <span class=\"nx\">Room</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n\n\t<span class=\"na\">num</span> <span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n\n\t<span class=\"na\">ceil</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n\n\t<span class=\"na\">ele</span> <span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">pre</span><span class=\"dl\">'</span>\n\n<span class=\"p\">}</span> <span class=\"c1\">// 는 안되는데 </span>\n\n\n\n<span class=\"kd\">const</span> <span class=\"nx\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n\n\t<span class=\"na\">num</span> <span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n\n\t<span class=\"na\">ceil</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n\n\t<span class=\"na\">ele</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n\n<span class=\"p\">}</span>\n\n  \n\n<span class=\"kd\">const</span> <span class=\"nx\">r</span> <span class=\"p\">:</span> <span class=\"nx\">Room</span> <span class=\"o\">=</span> <span class=\"nx\">obj</span>\n\n</code></pre></div></div>\n<p>Q. 두번째는 객체를 선언하고 그 객체를 변수에 할당해주니 <span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  구조적 타이핑  <span class=\"invalid-link-brackets\">]]</span></span>이 먹힌다…??? \n-&gt; 타입스크립트 잉여체크를 항상 해주는 것이 아니다?? \n-&gt; 그 전 타입을 굳이 또 타입을 해줄 필요가 없도록 하려고?</p>\n\n<p>이유: obj 타입은 Room 타입의 부분 집합을 포함하고 있기때문에 타입 체커에서 통과?! 조금 이해가 될랑 말랑</p>\n\n<h4 id=\"두-예제간의-차이점\">두 예제간의 차이점.</h4>\n<p>첫번째 예제는 <span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  잉여 속성 체크  <span class=\"invalid-link-brackets\">]]</span></span>라는 속성이 수행 , 할당 가능 검사 !== 잉여 속성 체크.</p>\n\n<h5 id=\"타입-스크립트-타입-지정은-포괄적으로-지정도-가능하다\">타입 스크립트 타입 지정은 포괄적으로 지정도 가능하다</h5>\n<div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">interface</span> <span class=\"nx\">Options</span> <span class=\"p\">{</span>\n<span class=\"nl\">title</span><span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"nl\">darkMode</span><span class=\"p\">?:</span> <span class=\"nx\">boolean</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">o1</span> <span class=\"p\">:</span> <span class=\"nx\">Options</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">;</span>\n<span class=\"kd\">const</span> <span class=\"nx\">o1</span> <span class=\"p\">:</span> <span class=\"nx\">Options</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">HTMLAnchorElement</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<p>document, HTMLAnchorElement 모두 string 타입인 title 속성을 가지고 있어서 할당문이 정상!! 아하</p>\n\n<h5 id=\"아직-흩어진-지식\">아직 흩어진 지식</h5>\n<p>#흩어진지식 객체 리터럴이 아니면 잉여속성체크가 적용되지 않는다.\n#흩어진지식 또한 타입 단언문을 사용할때에도 적용되지 않는다.</p>\n\n<h4 id=\"요약\">요약</h4>\n<ol>\n  <li>객체 리터럴을 변수 할당 혹은 함수의 매개변수로 전달할때 잉여 속성 체크가 수행된다.</li>\n  <li>잉여 속성 체크는 오류를 찾는데는 효과적이지만 일반적인 구조적 할당 가능성 체크와 다르다. \n -&gt; 뭐가 다른데!!!</li>\n  <li>임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.</li>\n</ol>\n\n<h3 id=\"함수-표현식에-타입-적용하기\">함수 표현식에 타입 적용하기</h3>\n<p><strong>타입스크립트에서는 함수 표현식을 사용하는 것이 좋다.</strong></p>\n\n<p>#Q why? 매개변수 부터 return값 까지 전체를 함수 타입으로 선언하여 표현식에 재사용할 수 있기에\n-&gt; 코드를 확인해보니 선언문은 인자를 무조건 할당해야한다. \n-&gt; 형식이 다르다 \n-&gt; 눈으로 확인해보기</p>\n\n<p>#Q 선언문은 안되나? 동일하지 않나? 타입스크립트 함수 타입이 표현식 타입으로 정의되어있나?</p>\n\n<p>함수 타입 선언으로 중복되는 코드의 반복을 줄인다!</p>\n<div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">add</span> <span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">:</span><span class=\"kr\">number</span><span class=\"p\">,</span> <span class=\"nx\">b</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">a</span> <span class=\"o\">+</span> <span class=\"nx\">b</span><span class=\"p\">};</span>\n<span class=\"kd\">function</span> <span class=\"nx\">sub</span> <span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">:</span><span class=\"kr\">number</span><span class=\"p\">,</span> <span class=\"nx\">b</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">a</span> <span class=\"o\">+</span> <span class=\"nx\">b</span><span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">mul</span> <span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">:</span><span class=\"kr\">number</span><span class=\"p\">,</span> <span class=\"nx\">b</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">a</span> <span class=\"o\">+</span> <span class=\"nx\">b</span><span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">div</span> <span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">:</span><span class=\"kr\">number</span><span class=\"p\">,</span> <span class=\"nx\">b</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">a</span> <span class=\"o\">+</span> <span class=\"nx\">b</span><span class=\"p\">}</span>\n\n<span class=\"o\">-&gt;</span>\n<span class=\"kd\">type</span> <span class=\"nx\">BinaryFn</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">:</span> <span class=\"kr\">number</span> <span class=\"p\">,</span> <span class=\"nx\">b</span><span class=\"p\">:</span><span class=\"kr\">number</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"kr\">number</span><span class=\"p\">;</span>\n<span class=\"kd\">function</span> <span class=\"nx\">add</span><span class=\"p\">:</span> <span class=\"nx\">BinaryFn</span><span class=\"p\">(</span><span class=\"nx\">a</span><span class=\"p\">,</span> <span class=\"nx\">b</span> <span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">a</span> <span class=\"o\">+</span> <span class=\"nx\">b</span><span class=\"p\">};</span>\n<span class=\"p\">...</span>\n</code></pre></div></div>\n\n<p>#흩어진지식 <a class=\"internal-link\" href=\"/react-moc\">react MOC</a>에서는 MouseEvent라는 타입 대신에 함수 전체에 적용할 수 있는 MouseEventHandler 타입을 제공한다.</p>\n\n<h4 id=\"fetch-예시\">fetch 예시</h4>\n<div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">checkedFetch</span> <span class=\"p\">(</span><span class=\"nx\">input</span> <span class=\"p\">:</span> <span class=\"nx\">RequestInfo</span><span class=\"p\">,</span> <span class=\"nx\">init</span><span class=\"p\">?:</span><span class=\"nx\">RequestInt</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"kd\">const</span> <span class=\"nx\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">fetch</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">,</span> <span class=\"nx\">init</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">ok</span><span class=\"p\">){</span>\n\t<span class=\"c1\">//거절된 프라미스</span>\n\t<span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"nx\">res</span><span class=\"p\">.</span><span class=\"nx\">status</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n<span class=\"k\">return</span> <span class=\"nx\">res</span>\n<span class=\"p\">}</span>\n\n<span class=\"o\">--&gt;</span> <span class=\"nx\">더</span> <span class=\"nx\">간결하게</span> <span class=\"nx\">타입</span> <span class=\"nx\">지정</span>\n<span class=\"kd\">const</span> <span class=\"nx\">checkedFetch</span><span class=\"p\">:</span> <span class=\"k\">typeof</span> <span class=\"nx\">fetch</span> <span class=\"o\">=</span> <span class=\"k\">async</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">,</span> <span class=\"nx\">init</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>\n\t<span class=\"kd\">const</span> <span class=\"nx\">res</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">fetch</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">,</span><span class=\"nx\">init</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">res</span><span class=\"p\">.</span><span class=\"nx\">ok</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"p\">...</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">...</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>함수 선언문 =&gt; 표현식 함수 전체에 타입을 줬는데 함수 전체 타입은 뭐뭐가 지정되어있는거지?</p>\n\n<h4 id=\"결론-1\">결론</h4>\n<ol>\n  <li>함수 같은 경우는 매개변수에 타입을 지정하는 것보다 한단계 올라와서 함수 전체에 타입을 지정해주는 것이 간결하고 안전하다.</li>\n  <li>다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다. 아하!!</li>\n</ol>\n\n<h3 id=\"타입과-인터페이스의-차이점-알기\">타입과 인터페이스의 차이점 알기</h3>\n<blockquote>\n  <p>드디어!! 가보자고</p>\n</blockquote>\n\n<p>타입스크립트에는 type을 정의하는 두가지 방식</p>\n<ol>\n  <li><strong>type</strong></li>\n  <li><strong>interface</strong></li>\n</ol>\n\n<p>#Q. 클래스는 값으로 쓰일 수 있는 자바스크립트의 런타임의 개념? 혹시 이해되나요?  봐도 봐도 어색한 느낌</p>\n\n<p>대부분은 type, interface 어떤 식별자를 쓰던 상관 없다. \n하지만 일관성을 유지하려면 기준이 있어야하고 결국 차이를 알아야 기준이 생긴다는 말을 한다.</p>\n\n<h4 id=\"공통점\">공통점</h4>\n<p>우선 두 방식의 정의는 결과적으로 상태에는 차이가 없다.</p>\n<ol>\n  <li>\n<span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  index signiture  <span class=\"invalid-link-brackets\">]]</span></span> 모두 사용 가능</li>\n  <li>함수 타입 정의 가능</li>\n  <li>타입 별칭과 인터페이스는 모두 제네릭이 가능하다. \n 인터페이스가 타입을 확장할때는 <mark>조심</mark>해야할 것이 있고 타입이 인터페이스를 확장할때는 자유롭다.</li>\n</ol>\n\n<p>-&gt; 조심할 부분</p>\n<ul>\n  <li>인터페이스는 유니언 타입같은 복잡한 타입은 확장하지 못한다. 그래서 &amp;사용?</li>\n</ul>\n\n<h4 id=\"다른점\">다른점</h4>\n<ol>\n  <li>유니온 타입  O  /  유니온 인터페이스 X \n -&gt; type 키워드는 유니온도 되고 매핑된 타입 또는 조건부 타입같은 고급기능에도 활용할 수 있지만 interface는 불가</li>\n  <li>튜플, 배열도 타입은 간결하게만들 수 있다.\n    <div class=\"language-tsx highlighter-rouge\">\n<div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"c1\">// type</span>\n <span class=\"kd\">type</span> <span class=\"nx\">Pair</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kr\">number</span><span class=\"p\">,</span> <span class=\"kr\">number</span><span class=\"p\">]</span>\n <span class=\"kd\">type</span> <span class=\"nx\">StringList</span> <span class=\"o\">=</span> <span class=\"kr\">string</span><span class=\"p\">[];</span>\n\n <span class=\"c1\">// interface</span>\n <span class=\"kr\">interface</span> <span class=\"nx\">Tuple</span> <span class=\"p\">{</span>\n     <span class=\"nl\">name</span> <span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n     <span class=\"nl\">capital</span> <span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n <span class=\"kd\">const</span> <span class=\"nx\">t</span><span class=\"p\">:</span> <span class=\"nx\">Tuple</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"mi\">20</span><span class=\"p\">]</span> <span class=\"c1\">//작동은 하지만 매소드를 사용할 수 없다.</span>\n\t\n</code></pre></div>    </div>\n  </li>\n  <li>그렇다면 타입이 상위호환인 건가? 아니다 . interface에는 Type에 없는 기능이 있다.\n 1) <strong>arguments</strong>\n    <div class=\"language-tsx highlighter-rouge\">\n<div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"kr\">interface</span> <span class=\"nx\">IState</span> <span class=\"p\">{</span>\n <span class=\"nl\">name</span><span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n <span class=\"kr\">interface</span> <span class=\"nx\">IState</span> <span class=\"p\">{</span>\n <span class=\"nl\">population</span><span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n\t\n\n <span class=\"kd\">const</span> <span class=\"nx\">ju</span><span class=\"p\">:</span><span class=\"nx\">IState</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n <span class=\"na\">name</span><span class=\"p\">:</span><span class=\"dl\">'</span><span class=\"s1\">ju_young</span><span class=\"dl\">'</span><span class=\"p\">,</span>\n <span class=\"na\">population</span><span class=\"p\">:</span><span class=\"mi\">500000</span>\n <span class=\"p\">}</span>\n\n</code></pre></div>    </div>\n  </li>\n</ol>\n\n<h4 id=\"사용-방법의-기준\">사용 방법의 기준</h4>\n<ol>\n  <li>기존 타입에 추가적인 보강의 필요성 여부</li>\n  <li>복잡하면 Type , 간단하면 interface</li>\n  <li>API에 대한 타입 선언은 interface로 작성하는게 좋다. 하지만 타입 병합이 잘못될 수 있는 경우는 Type? 뭐야 이 작자!!</li>\n</ol>\n\n<p>#Q 보강과 typeScript 바벨과 연관이 있다.</p>\n\n<h4 id=\"결론-2\">결론</h4>\n<p>일관된 스타일을 사용하고 보강이 필요한지에 따라 결정</p>\n\n<p><strong>1/17 (화)</strong></p>\n<h3 id=\"타입-연산과-제너릭-사용으로-반복-줄이기\">타입 연산과 제너릭 사용으로 반복 줄이기</h3>\n<p>DRY 원칙에 대해 설명 -&gt; 타입에 대해서 간과가능성 -</p>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">interface</span> <span class=\"nx\">Person</span> <span class=\"p\">{</span>\n<span class=\"nl\">firstName</span><span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"nl\">lastName</span> <span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kr\">interface</span> <span class=\"nx\">PersonWithBirthDate</span> <span class=\"p\">{</span>\n<span class=\"nl\">firstName</span><span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"nl\">lastName</span><span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"nl\">birth</span><span class=\"p\">:</span> <span class=\"nb\">Date</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>타입 중복은 코드 중복 만큼 문제를 발생시킨다?</p>\n\n<p><strong>핵심</strong> : 타입간에 매핑하는 방법을 익히면 타입 정의에서도 DRY의 장점을 적용할 수 있다.</p>\n\n<h4 id=\"반복을-줄이는-방법\">반복을 줄이는 방법</h4>\n<ol>\n  <li>간단한 방법 타입에 이름을 붙이는 것. \n-&gt; 우리가 익히 사용하는 방법인데 상수를 사용해서 반복을 줄이는 방식으로 타입 시스템에도 적용한 것.\n1-1. interface에서 공통적인 부분은 <strong>extends</strong>를 사용하거나 <strong>&amp;</strong>을 통해서 확장 가능\n```ts\ninterface Person {\nfirstName: string;\nlastName : string;\n}</li>\n</ol>\n\n<p>interface PersonWithBirthDate extends Person {\nbirth: Date;\n}</p>\n\n<p>type PersonWithBirthDate Person &amp; {birth : Date}</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\n#Q. 이런 기법이 유니온 타입에 속성을 추가하려고 할떄 유용하다고 하는데 왜지?\n-&gt; 타입 확장을 유연하게 하려고 \n\n\n```ts\ninterface State {\n\tuserId: string;\n\tpageTitle:string;\n\trecentFiles: string[];\n\tpageContents:string;\n}\n\ninterface TopNavState {\n\tuserId : string;\n\tpageTitle: string;\n\trecentFiles: string[];\n}\n</code></pre></div></div>\n\n<p>#Q 이것도 extends를 활용해서 타입을 정의하면 되지 않나? 왜 다른 방식으로 하지?\n-&gt; state의 부분 집합으로 TopNavState를 정의 -&gt; State를 인덱싱하여 속성의타입에서 중복을 제거할 수 있다.\n-&gt; 논리적으로 생각하여 다시 정리</p>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">type</span> <span class=\"nx\">TopNavState</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"na\">userId</span> <span class=\"p\">:</span> <span class=\"nx\">State</span><span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">userId</span><span class=\"dl\">'</span><span class=\"p\">];</span>\n<span class=\"nl\">pageTitle</span><span class=\"p\">:</span> <span class=\"nx\">State</span><span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">pageTitle</span><span class=\"dl\">'</span><span class=\"p\">];</span>\n<span class=\"nl\">recentFiles</span><span class=\"p\">:</span> <span class=\"nx\">State</span><span class=\"p\">[</span><span class=\"dl\">'</span><span class=\"s1\">recentFiles</span><span class=\"dl\">'</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">//여전히 중복된다고 한다</span>\n\n<span class=\"kd\">type</span> <span class=\"nx\">TopNavState</span> <span class=\"o\">=</span><span class=\"p\">{</span>\n<span class=\"p\">[</span><span class=\"nx\">k</span> <span class=\"k\">in</span> <span class=\"dl\">'</span><span class=\"s1\">userId</span><span class=\"dl\">'</span> <span class=\"o\">|</span> <span class=\"dl\">'</span><span class=\"s1\">pageTitle</span><span class=\"dl\">'</span> <span class=\"o\">|</span> <span class=\"dl\">'</span><span class=\"s1\">recentFiles</span><span class=\"dl\">'</span><span class=\"p\">]:</span> <span class=\"nx\">State</span><span class=\"p\">[</span><span class=\"nx\">k</span><span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>이런식으로 인덱싱을 하면 무작정 중복된 타입을 지정했던 타입과 같이 동일한 정의가 표시되는 동시에 중복을 막을 수 있게 된다.</p>\n\n<p><span title=\"There is no note that matches this link.\" class=\"invalid-link\">  <span class=\"invalid-link-brackets\">[[</span>  mapped type  <span class=\"invalid-link-brackets\">]]</span></span></p>\n\n<p>#Q 제네릭 타입은 함수와 비슷하다?</p>\n\n<div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">interface</span> <span class=\"nx\">Options</span> <span class=\"p\">{</span>\n<span class=\"nl\">width</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">;</span>\n<span class=\"nl\">height</span> <span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">;</span>\n<span class=\"nl\">color</span> <span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"nl\">label</span><span class=\"p\">:</span> <span class=\"kr\">string</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n  \n\n<span class=\"c1\">// interface OptionsUpdate {</span>\n<span class=\"c1\">// width?: number;</span>\n<span class=\"c1\">// height? : number;</span>\n<span class=\"c1\">// color? : string;</span>\n<span class=\"c1\">// label?: string;</span>\n<span class=\"c1\">// }</span>\n\n  \n\n<span class=\"kd\">class</span> <span class=\"nx\">UIWidget</span> <span class=\"p\">{</span>\n\n<span class=\"kd\">constructor</span> <span class=\"p\">(</span><span class=\"nx\">init</span><span class=\"p\">:</span> <span class=\"nx\">Options</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n<span class=\"nx\">update</span> <span class=\"p\">(</span><span class=\"nx\">options</span> <span class=\"p\">:</span> <span class=\"nx\">OptionsUpdate</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n<span class=\"p\">}</span>\n\n  \n\n<span class=\"kd\">type</span> <span class=\"nx\">OptionsUpdate</span> <span class=\"o\">=</span> <span class=\"p\">{[</span><span class=\"nx\">k</span> <span class=\"k\">in</span> <span class=\"kr\">keyof</span> <span class=\"nx\">Options</span><span class=\"p\">]?:</span> <span class=\"nx\">Options</span><span class=\"p\">[</span><span class=\"nx\">k</span><span class=\"p\">]};</span>\n</code></pre></div></div>\n\n<p><mark>흩어져있는 지식 모음 (나중에 한데 모아 정리)</mark>\n<strong>keyof</strong>는 타입을 받아서 속성 타입의 유니온을 반환한다!!</p>\n\n<ul>\n  <li>값의 형태에 해당하는 타입을 정의하고 싶을때 \n<strong>typeof</strong>\n```ts\nconst INIT_OPTIONS = {\nwidth: 640,\nheight: 480,\ncolor: ‘1213’,\nlabel: ‘VGA’,\n}</li>\n</ul>\n\n<p>// interface Options {\n// width: number;\n// height: number;\n// color: string;\n// label: string;\n// }</p>\n\n<p>type Options = typeof INIT_OPTIONS</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\n런타임의 연산자 typeof 가 아니라 컴파일 단계에서 연산되고 자스 typeof보다 더욱 정확하다고 한다. \n\n#Q 값은 런타임에 할당되는거 아닌가? 어떻게 값으로 부터 타입이 만들어지지? \n\n값으로 부터 만들어져서 선언 순서가 중요 타입 정의 -&gt; 값이 그 타입에 할당 가능하다고 선언하는 것이 베스트\n\n- 함수나 메서드 반환값에 커스텀하여 정의... -&gt;  을 만들 수 있다.\n-&gt; 명명된 타입 : Options (타입 별칭)\n-&gt; 조건부 타입이 필요하다.  -&gt; ReturnType 제네릭\n```ts\ntype UserInfo = ReturnType&lt;typeof getUserInfo&gt;;\n</code></pre></div></div>\n\n<ul>\n  <li>typeof의 대상이 값인지 타입인지 알고 처리해야한다. 여기서는 타입!</li>\n</ul>\n\n<p><mark>흩어져있는 지식 모음 (나중에 한데 모아 정리)</mark>\n제네릭 타입은 타입을 위한 함수와 같다.</p>\n\n<ul>\n  <li>summary\n    <ol>\n      <li>타입 정의에도 DRY 최대한 적용</li>\n      <li>이름을 붙여서 반복을 피하고 extends를 사용해서 interface의 필드의 반복을 피해야한다</li>\n      <li>매핑을 위한 도구들 (keyof, typeof, indexing,  mappinged type) 공부하는 것 추천</li>\n      <li>타입을 반복하지 않도록 제네릭 타입을 사용하여 타입들 간에 매핑을 하는것이 좋다.</li>\n      <li>표준 라이브러리 Pick, Partial, ReturnType 같은 제네릭타입에 익숙해지자.</li>\n    </ol>\n  </li>\n</ul>\n\n<h3 id=\"동적-데이터에-인덱스-시그니처-사용하기\">동적 데이터에 인덱스 시그니처 사용하기</h3>\n<p>자바스크립트의 장점 중 하나 : 객체를 생성하는 문법이 간단하다\n<a class=\"internal-link\" href=\"/advantage-of-js\">Advantage of JS</a>\n-&gt; 자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑한다. \n의미 :</p>\n\n<pre><code class=\"language-Ts\">type Rocket = {[property: string]:string}\n\nconst rocket : Rocket = {\n\nname : 'Flcon',\n\nvariant: 'df',\n\nthrust : 'sdfds'\n\n}\n</code></pre>\n\n<p><code class=\"language-plaintext highlighter-rouge\">[property: string]:string</code> 가 인덱스 시그니처고 세가지 의미를 담고 있다.</p>\n\n<ol>\n  <li>키의 이름: 키의 위치만 표현하는 용도</li>\n  <li>키의 타입: string 혹은 number 또는 symbol의 조합이어야 하지만 보통 string을 사용한다</li>\n  <li>값의 타입 : 어떤 것이든 될 수 있다.</li>\n</ol>\n\n<p>위의 방식대로 타입 체크가 수행되면 단점 4가지</p>\n<ol>\n  <li>모든 키 허용</li>\n  <li>키가 필요하지 않은 것</li>\n  <li>동일한 타입 요구</li>\n  <li>자동완성 사용 불가</li>\n</ol>\n\n<p>위에서 본 인덱스 시그니처는 부정확해서 인터페이스 사용해야한다. 그럼 인덱스 시그니처는 언제 사용해야하는거지?\n-&gt; <strong>동적 데이터</strong>를 표현할때 -&gt; 동적 데이터가 뭔데? (계산되고 가공되는 데이터) -&gt; 언제 사용되는데?(서버에서 실시간으로 변환되어 적용이 될떄 사용됨 ) \n-&gt; 서버 데이터는 스키마를 알기에 동적 데이터가 아니다. 왜냐하면 스키마가 있으니깐 (영준)\n-&gt; 추가적으로 타입을 확장시키고 싶을떄 사용했던 것 같다 (태희)</p>\n\n<p>-&gt; 객체의 키값을 미리 알 수 없을때 사용하는 방식이라는 것 같다.</p>\n\n<p>인덱스 시그니처를 사용하지 않아야할떄 -&gt; 타입이 정의되지 않고 제한되어있을때 \n사용할떄 -&gt; 타입의 범위가 포괄적일때? \n-&gt; 인덱스 시그니처 사용시 에러가 많이 나옴.\n-&gt; <mark>안쓰는게 답이다.</mark></p>\n\n<ul>\n  <li>요약\n    <ol>\n      <li>런타임까지 객체 속성을 알 수 없을떄 인덱스 시그니처 사용</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td>안전한 접근 위해서 시그니처 값 타입에</td>\n              <td>undefiend 추가 고려</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li>정확한 타입 선언 사용 권장</li>\n    </ol>\n  </li>\n</ul>\n\n<h3 id=\"number-인덱스-시그니처보다는-array-튜플-arraylike-사용하기\">number 인덱스 시그니처보다는 Array, 튜플, arrayLike 사용하기</h3>\n<p><a class=\"internal-link\" href=\"/limitation-of-js\">limitation of JS</a>\n자바스크립트에서 객체는 key/value의 모음</p>\n<ul>\n  <li>객체의 키값으로는 숫자와 객체를 사용할 수 없다.</li>\n  <li>배열의 타입은 객체\n```js\nx = [1,2,3]\nx[0] // 1</li>\n</ul>\n\n<p>x[‘0’] // 문자열이어도 값이 나온다.</p>\n\n<p>let x = [1,2,3]\nconsole.log(Object.keys(x)) /// [ ‘0’, ‘1’, ‘2’ ]\n```</p>\n\n<p>위의 문제를 해결하기 위해 타입스크립트는 숫자를 키로 허용하고 문자열 키와 다른 것으로 인식하다.</p>\n\n<p>92Page 너무 어렵다.</p>\n\n<h3 id=\"변경-관련된-오류-방지를-위해-readonly-사용하기\">변경 관련된 오류 방지를 위해 readonly 사용하기</h3>\n\n<p>-&gt; 잠시 내려놓음. 모르겠음</p>\n\n<p>매개변수에 readOnly 해놓으면 값을 못바꾼다</p>\n\n</body></html>"
  ],
  "collection": "notes",
  "tags": [

  ],
  "categories": [

  ],
  "slug": "Advantage of JS",
  "type": "document",
  "url": "/advantage-of-js"
}
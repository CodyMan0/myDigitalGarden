---
---

# 비플라이
1. 자기소개 
2. 회사 서비스를 써보셨나요?
3. 회사가 어떤 느낌이지?
-> 딱딱해보였으나 어플을 보면 부드럽다
4. 2018년 군대끝나고 학원을 두군데 다녔다?  
-> 
말이 길다.

5. 8.13일 블로그에 fetch method가 이런거구나편을 보았는데 그땐 fetch method가 어떤 느낌이셨나요. 그떄 강점은 어땠는지
-> 재밌었다. 백앤드와 프론트앤드 
6. 지금 과거로 돌아가서 그 당시 자신에게 어떻게 도와줄것같은지 (의도한 대답이 안나와서 다시 질문)
->  쉽게 사용할 수 있는 예시를 보여준다. 
-> 고민
-> 왜를 알려주면 혼자 잘한다. 
-> 툴을 원하신 대답! 
-> postman 
-> 적당히 사용하는 것이 좋다 


7. 클린코드에 대해 적어놓고 정리는 안하셨는데 어떤 느낌으로 배워서 소화를 했는지 궁금하다.

8. 스터디 따로 하시고 계신가요? 아직 배우고 있는 단계라고 보면 돼죠? 

9. 뻔한 질문부터 useEffect , useState에 대해 간단하게 설명


11.  가상돔
diffing 알고리즘을 활용해서 얕은 비교로 ㅁ컴포넌트간에 변화를 감지하여 효율적으로 바꿔주는 리액트를 인기있도록 하는 원동력이라 

12. 리액트의 단점은 뭐라고 생각하는지
자유도가 높아서 상대적으로 어렵다. 

13. 그 반대로 장점을 가지고 있는 것을 알고 있는지?
뷰, 앵귤러 

14. 뷰는 개인적으로 공부하셨나요?
이제서야 공부하는 과정에 있다. 

15. 알고리즘 관련 적어보라고는 안한다. **길찾기 알고리즘**에 대해 아는 것 목록에 대해 설명을 해달라
-> 길찾기 알고리즘은  [[graph and search(DFS,BFS)]]

16. 만약에 들어와서 다음프로젝트부터 뷰를 한다고 하면 어떤 느낌?
전 완전 

# 영준 (비팩토리)

함수에서 왜 인자를 바꾸면 안되는지(**call by reference call by value**)
 [[shallow and deep copy]]

함수 호출 방법 크게 두가지
[[call by value]]
[[call by reference]]


오래된 라이브러리 사용시 new promise 사용


해쉬맵
-> 자바스크립트  new Map

리액트가 성능보장하는 방법
[[react MOC]]


언어별 내가느낀 차이점 자스 타스
->

코테 문제에서 오브젝트로 이중 loop을 막을 수 있어 리액트 훅과 커스텀훅 언제 왜
->

Next ssr언제 왜 사용했는지 seo, datafetching
->

두 프로젝트 설계한 authentication과정타입을 어떻게 설계하는 편인지
->

싱글 스레드 멀티 스레드
->

왜 개발 시작했는지
-> 

어떻게 공부해왔는지


# 빌리버 (1.17)
1. 자기 소개 해주세요
2. 회사에 대해서 알아보고 왔느냐
3. 이력서에는 타입스크립트가 있었으나 깃허브에는 진행한 프로젝트가 없는데 진행하고 있는 프로젝트가 있는지? 
4. 최근 프론트앤드 관련 공부하고 있거나 관심있는 기술이 있느냐
5. 둘다 CSR 로 만들었는데 다른 프레임워크 써본적있냐
6. css는 좀 아시나요? 
7. React.js 와 vue.js의 차이 
8. recoil 상태관리 툴을 사용한 이유
9. 설문지 관리 프로젝트 PM 역할은 어떤 역할을 수행한건지? 
10. PM의 역할이 무엇일까요?
11. 호이스팅이 무엇이냐? 
	-> 스코프 최상단 끌어올려지는 것 처럼 보이게 하는것 -> 예상치 못한 에러를 발생시킨다. 
12. 타입스크립트의 장점 혹은 단점 
	-> 타입 자동완성이 장점 단점은 모르겠다. 
13. get Post의 차이
14. http 헤더 안에 파라미터를 넣고 받아본 경험을 한적있냐? 
15. 프론트엔드 개발자로서 어떤 역량이 있어야 성장하는데 도움이 될 수 있을 것 같냐? 
16. 옵시디언 정리한것 볼 수 있냐? 
17. ==코오롱에서 팀원간의 이슈 그리고 해결 과정==
	-> 대답을 잘 못함
	-> 신경을 많이 써야한다? 아니다
	-> 문서적 소통이 중요하다 라고 정정
18. 



# 영준 (클라썸)
퍼블리싱이란  
랜더링에서 js의 역할은  
Csr과 ssr  
SEO와 csr ssr에서의 차이, 직접 사용한 경험  
Callback promise async-await 에대해  
비동기 처리과정  
렌더링 과정  
쿠키 브라우저 storage  
Axios에 대해서  
Data binding  
Props와 state의 차이  
전역 상태관리는 어떤걸 하는지 주로  
컴포넌트 설계  
흰화면이 떳을때 어떻게 해결할지  
Git flow에서 왜 브렌치 다 지웠는지  
도움되는 개발자 도구 3가지  
서버리스라는 표현의 의미  
어느정도 경력이라 생각하는지  
어떻게 공부하고 최근 본 블로그나 책






# 주영 면접 질문
![[사전 면접 질문지.pdf]]


#### 1. Spread Operator Syntax 사용시 주의해야할 사항들을 shallow Copy와 연관지어 서술해주새요.

주의 해야할 것은 Spread Operator 즉 전개 문법은 객체 안에 있는 원시형 value값은 불변하게 복사가 되지만 참조형 value 객체나 배열 같은 경우는 얕은 복사가 이루어져 동일한 참조값을 가지게 돼 원본에 영향을 주어 예측하기 어려운 에러를 개발자의 실수로 하여금 일어날 수 있게 합니다. 

중첩된 객체 혹은 배열이 복사가 되지 않는 문제  해결
방법 1. 객체의 형태에 맞게 spread Operator 사용

```js
const a = {
  foods : {
  dinner : 'pasta'
	}
}

let b = {foods:{...a.foods}}

b.foods.dinner = 'Soup'

a.foods.dinner
```
하지만 객체 형태가 복잡해질 경우 어려움을 초래 

방법 2 . JSON 내장 객체 사용 
객체 DEEP copy (JSON.parse(JSON.stringify(a)))
```js
const a = {
  foods: {
    dinner: 'Pasta'
  }
}
let b = JSON.parse(JSON.stringify(a))

b.foods.dinner = 'Soup'
console.log(b.foods.dinner) // Soup
console.log(a.foods.dinner) // Pasta
```

이런식으로 json으로 바꾸고 parse하면 deep Copy가 이루어진다. 

근데 왜?  연달아 호출하면 동일한 객체트리를 가지는 객체를 복제한다. 

하지만 여기에도 문제가 있다. 함수 타입은 JSON형태에 없어 누락이 된다는 것. 

방법 3  **lodash 라이브러리 사용** 


관련있는 메모 
- [[shallow and deep copy]]
- [[JSON format]]

#### 2. props Drilling 이란 무엇이고 효율적인 컴포넌트 작성을 위해 어떤 개선점이 있을지 서술 해주세요.
핵심적으로 말씀드리면 props Drilling으로 인해 생기는 가장 큰 문제는 ==불필요한 컴포넌트까지 렌더링==을 시킨다는 것입니다. 공식 문서 ->context

관련있는 메모 : [[react MOC]]
[[wanted-pre-onboarding]]


#### 3. react에서 배열의 항목을 렌더링하고자 할때 각 요소에 key 값을 인덱스로 사용했을떄 생기는 문제에 대해 서술해주세요

key index 사용할때 추가 삭제할때 문제 -> 추가 삭제 시, 요소들의 키가 변화하는 문제 ->  추가될때 배열 전체가 리랜더링 -> 추가 된 요소 만큼 밀리는 현상 -> 가상돔 변화 인지 -> 불필요한 리렌더링 -> 의도되지 않은 문제! -> 유니크한 값을 가지도록 해야한다. 

추가 혹은 삭제 가 일어날때 key값이 계속 바뀌어 배열 전체가 리렌더링이 일어나는 문제!  


[[react MOC]]


#### 4. Hook을 통해 컴포넌트를 개선한 경험이 있는지? 어떤 문제를 해결하기 위해 사용했는지 설명해주세요.


진혁님 
-> react-hook-form  -> 이게 더 좋다. 

-> 무한 스크롤 경험 

[[hook MOCs]]



#### 5. API를 통해 배열의 크기가 최소 1000이상인 응답을 받아 렌더링하고자 할때 퍼포먼스 측면에서 어떤 점을 고려해야할지 서술

1순위 불필요한 랜더링이 발생되지 않도록 근본적으로 코드를 개선 ->  (자료구조를 생각)
	-> 자료구, 알고리즘 
2순위 컴포넌트 최적화 고려? 

-> 대부분 최악의 경우를 들어 생각을 하지만 반대로 최소 1000이상의 배열이라고 가정한다면 렌더링 측면을 고려해야하지 않을까 싶습니다. 배열의 크기가 1000이상이니 데이터에 따른 UI가 화면에 그려지는데 다소 오래 걸릴 것 같습니다. 또한  새로운 값을 만드는 연산이 복잡할 것이라고 생각합니다. 

#### 6. useMemo, useCallback을 통한 최적화 원리를 불변성과 관련지어 설명해주세요 
useMemo와 useCallback 모두 리액트 내에서 함수 컴포넌트에서 값을 memo할 수 있도록하는 API 입니다. 

-> 최적화는 기존 컴포넌트의 UI를 재사용할 지 확인한다.
-> React.memo는 기본적으로 props 객체간을 비교하는 방식을 통해서 동작
-> [[자바스크립트 데이터 타입]]과 연관있는 것이 불변성인데 이 부분을 최적화 원리와 관련짓는다? 
-> [[useMemo]]
 [[얕은 비교]]


리액트가 불변성을 가지고 있기에 가상돔이 참조값만 비교해서 변화를 감지할 수 있게 한다. 

useState 새로운 참조값을 만들어서 사용한다. 

**리액트 불변성** -> 가상돔 원리 -> useMemo, useCallback 메모이제이션 된 값 불로오기 -> 불필요한 렌더링 제거 -> 최적화


[[react MOC]]
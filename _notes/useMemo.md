---
aliases: [useMemo]
tags : 
---

출처 :
저자 :
URL : 
인용 : 
# 사용 방법 
```js
// useMemo(callbackFunction, deps] 
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

첫 인자는 콜백함수 두번째 인자는 의존성 배열 

## useMemo 를 사용하여 연산한 값 재사용하기


### 사용 예시
item이라는 객체는 리렌더링할때마다 다른 참조값을 가지므로 React.memo에 적용을 받지 못한다. 이럴때 useMemo 훅을 아래와 같이 사용하면 된다. 이렇게 하면 React.memo에 적용을 받을 수 있다. 

![[스크린샷 2022-09-21 오전 8.57.08.png|400]]

### 사용 이유
1.  새로운 값을 만드는 연산이 복잡하다.
2.  함수 컴포넌트의 이전 호출과, 다음 호출 간 사용하는 값의 **동일성을 보장하고 싶다.**


실제 객체의 내용은 똑같아도 [[얕은 비교|얕은비교]]를 통해서 다른 객체라고 판단되어서 매번 리렌더링이 실행되는 상황일떄  전달되는 객체의 동일성을 보장하기 위해서 메모이제이션을 활용할 수 있습니다.

메모이제이션 된 객체는 새롭게 만들어진 것이 아니라 이전의 객체를 그대로 활용하는 것이기에 shallow compare에서 **동일함을 보장**받을 수 있습니다.


### 생각의 연결고리
분야 :

키워드 :

관련있는 메모 : [[react optimization]]

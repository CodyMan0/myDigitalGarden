---
---

- 원시형
	- undefined ,null, Boolean, Number, String,, Symbol
- 참조형
	- Object : new Object Array, Map, Set, Weak map, Date 
	- Function 




React.memo는 기본적으로 props 객체간을 비교하는 방식을 통해서 동작합니다. 이를 잘 인식하고 활용하려면 자바스크립트의 데이터 타입, 그중에서도 기본형 타입과 참조형 타입
의 차이에 대해서 명확히 알고 있어야 합니다.


자바스크립트의 데이터 타입은 **string, number, boolean, null, undefined, object** 등 다양하게 있습니다. 그리고 이를 크게 두가지로 나누면 **기본형 타입**과 **참조형 타입**으로 구분할 수 있습니다.

기본형 타입은 원시형 타입이라는 용어로도 표현합니다. 단어 자체에서도 알 수 있듯이. 자바스크립트에서 지원하는 원시적이고 기본적인 형태의 데이터 타입이며 다른 데이터 없이 해당 데이터 스스로 온전히 존재할 수 있는 형태입니다. 원시형 타입의 예시에는 
**string, number, boolean, null, undefined, bigint, symbol** 이 있습니다.

참조형"(여러 값을 넣을 수 있는 주머니)" 타입은 달리말해 객체형 타입이라고도 불립니다. 즉 원시형 타입을 제외한 ==Object==가 참조형 타입이라고 할 수 있습니다(자바스크립트에서는 ==Array도 Function도 Object의 한 종류==입니다) 참조형 타입의 가장 큰 특징은 다른 데이터들을 모아서 만들어진 타입이라는 것입니다.

==const yeonuk = {name: “yeonuk”, gender:”male”}==

위의 객체를 보면 이 객체는 `“yeonuk”, “male”` 이란 두가지 string 타입을 모아서 만들어진 것을 확인할 수 있습니다.



# 참조형 타입과 기본형 타입을 생각할 때 고려해야 할 가장 큰 특징은 “불변성"입니다.

원시형 타입은 불변하다. 변수의 값이 바뀌게 되면 교체되는것이고 변경하는 것뿐 
참조형은 가변하다. 

그럼 객체를 불변하게 사용한다는 것은 코드로 보면
```jsx
const prev = {name:"prev", hello:"world"};
const next = {...prev, name:"next"}; prev === next // false
```

데이터 타입의 원시형 타입과 참조형 타입을 모르고 React.memo를 사용할때 잘못 코드를 사용할 수 있는 예시의 핵심은
함수는 객체이고 함수가 매번 렌더링때 생기는 애들의 값이 똑같더라도 참조값이 달라서 다른 객체로 인식하는 문제가 있다. 

이것을 해결하기 위해 Memorization을 활용해서 문제를 해결한다. 

# Memorization
1. useMemo = 값을 memorization 을 해주는 API 
	의존성 배열에 있는 값 중 하나라도 이전 렌더링과 비교했을 때 변경되었다면 메모된 값을 활용하는 것이 아니라 새로운 값을 다시 계산합니다.
2. useCallback = 함수를 저장할떄는 useCallback 쓰자
```jsx
const memorizedFunction = useMemo(() => () => console.log("Hello World"), []); 
const memorizedFunction = useCallback(() => console.log("Hello World"), []);
```

## 언제 메모해야할까? 
새로운 값을 만드는 것 vs 어딘가에 이전의 값을 저장해두고 메모이제이션 함수를 호출하고 의존성을 비교해서 가져올지 말지 여부를 판단하는 것 중 어떤 것이 비용이 더 적게 들까?

1.  새로운 값을 만드는 연산이 복잡하다. 
	10,000개 배열을 만드는 예시
2.  함수 컴포넌트의 이전 호출과, 다음 호출 간 사용하는 값의 **동일성을 보장하고 싶다.**
	왜? React.memo랑 연동해서 쓰려고 

# 언제 최적해야하는가? 

최적화를 해야 하는 시기는 이 최적화가 명확히 가치를 창출해낼 수 있을 것이라고 기대되는 상황 즉, 현재의 프로젝트에 성능적인 이슈가 발생했거나, 발생할 가능성이 있고 이를 해결해야 될 필요성이 있는 상황에서 수행하는 것입니다. 만약 내가 최적화를 하고 싶다면 현재 상황을 분석해서 최적화를 해야 하는 이유를 정리하고 이를 관련된 사람들에게 알리고 최적화의 필요성에 대한 공감대가 형성시키고 난 후 최적화를 수행해야 합니다.


### 관련한 메모 
1. [[자바스크립트의 한계]]를 알 수 있는 부분
2. [[리액트 상식]]
3. 

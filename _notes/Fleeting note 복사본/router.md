# 1. Routing

---

라우팅(Routing)과 관련된 용어를 먼저 정리하자면 Route는 ‘경로’라는 의미를 담고 있고, ==Routing은 ‘경로를 찾는 행위’==, ==Router는 Routing을 해주는 ‘도구’==라고 할 수 있습니다. **웹 프론트엔드에서 Routing은 다른 경로(url 주소)에 따라 다른 View(화면)를 보여주는 것**을 의미합니다.  
  
기존의 웹페이지에서는 html에 a 태그를 통해 링크를 걸고, 화면에서 해당 링크를 클릭했을 때 다른 html 페이지로 이동하는 방식으로 라우팅했습니다. 하지만 React에서는 다른 방식으로 라우팅을 구현해야 하는데, 그 이유는 무엇일까요?  
  
==1)우선 React(리액트)는 **Framework**가 아닌 **Library**이기 때문에 라우팅 기능이 내장되어있지 않습니다. 그래서 별도의 **Library**를 설치해서 라우팅을 구현해야 하고==, ==2)CRA를 통해서 만들 웹 애플리케이션은 SPA이기 때문에 기존의 라우팅 방식과는 다르게 라우팅을 구현해야 합니다.== 그렇다면 **SPA**는 무엇일까요?  
  

# 2. SPA

---

==SPA **(Single Page Application)**== 는 페이지가 하나인 웹 애플리케이션입니다. 여기서 **‘페이지’**란 **html 파일**을 뜻하기 때문에, SPA는 ==**html이 하나인 웹 애플리케이션**==을 의미합니다. 상반되는 개념으로는 ==html 파일이 여러 개인 MPA **(Multi Page Application)**==가 있습니다.  
  
MPA는 html 파일이 여러 개라서 다른 페이지를 보여 주고 싶을 때, 해당 html 파일을 연결해 보여주는 형태로 페이지를 이동하는 기능을 구현할 수 있었습니다. 하지만 SPA는 html 파일이 하나이기 때문에 하나의 html에서 경로(url)에 따라서 다른 UI를 보여주는 **라우팅 기능**이 필요하게 된 것입니다.  
  

# 3. React-Router

---

## 3-1. react-router-dom 설치

react-router-dom은 React에서의 라우팅을 위해 **가장 많이 사용되는 라이브러리**입니다.  
  

==$ npm install react-router-dom==

라이브러리 설치 방법은 위와 같습니다. 터미널에서 프로젝트 폴더로 이동한 뒤, 위와 같은 명령어를 작성하면 설치가 가능합니다.  
  

설치가 완료되었다면, 위처럼 package.json의 dependencies 항목에서 해당 패키지 명과 버전이 잘 추가되었는지 반드시 확인해 줍니다.

## 3-2. Router 컴포넌트

지금까지 **라우팅에 대한 개념**과 **SPA**에서 라우팅을 구현해야 하는 이유 그리고 라우팅 기능을 위해 가장 많이 사용되는 **라이브러리를 설치**하는 방법에 대해 알아봤습니다. 그렇다면 이제는 실제 프로젝트에서 **라우팅을 구현하는 방법**에 대해서 알아보도록 하겠습니다.

### 3-2-1. Router 컴포넌트를 만드는 이유


CRA를 통해 프로젝트를 만들고 npm start를 터미널에 입력하면, 최초 화면에서 **App 컴포넌트**의 내용을 볼 수 있게 됩니다. 하지만 지금은 아무리 url을 변경해도 똑같은 화면만 보이게 됩니다. 그래서 라우팅 기능을 구현하고 관리하기 위해서 Router 컴포넌트를 만들어줘야 합니다.  
  

### 3-2-2. Router.js 파일 위치


라우팅을 구현하기 위해 설치했던 react-router-dom 패키지에는 여러 컴포넌트가 포함되어 있고, 이 중에서 Router 컴포넌트를 구현하기 위해서는 **BrowserRouter, Routes, Route** 컴포넌트를 import 해야 합니다.  

라우터로 라우팅하는 방법

1.  ==BrowserRouter 컴포넌트로 전체==를 감싸줍니다.
2.  BrowserRouter 컴포넌트의 ==자식 요소로 Routes 컴포넌트==를 넣어줍니다.
3.  Routes 컴포넌트의 ==자식 요소로 Route 컴포넌트==를 넣어줍니다.

그렇다면, Router 컴포넌트를 구성하는 각각의 컴포넌트들은 어떤 ==역할==을 할까요?

우선, ==BrowserRouter== 컴포넌트는 주소 변경에 대해 다양한 편의 기능을 제공해 주는 컴포넌트입니다. ==대표적인 기능으로는 페이지가 새로고침 되지 않아도 주소 변경이 가능==하게 하는 기능이 있습니다.  
  
Routes 컴포넌트는 여러 Route를 감싸서 그중 ==규칙이 일치하는 라우트 단 하나==만을 렌더링 시켜주는 역할을 합니다.  
  
Route 컴포넌트는 규칙을 설정할 수 있는 컴포넌트입니다. Route 컴포넌트에서 어떻게 규칙을 설정하는지 조금 더 자세하게 살펴보도록 하겠습니다. Route 컴포넌트의 형식을 보면 html에서 사용한 태그의 형식과 **유사하다**는 것을 볼 수 있습니다. 예를 들어 input 태그에서 type 속성을 사용했던 것처럼 Route 컴포넌트에서는 ==**path** 와 **element** 속성을 사용==하고 있는 것을 볼 수 있습니다. Route 컴포넌트에서 ==path는 경로를 설정하는 속성==이고, **element**는 path 속성에서 설정한 경로로 이동했을 때, 어떤 ==컴포넌트를 보여줄지 결정하는 속성==입니다.(화면에 그려지는 UI를 담은 컴포넌트) 그렇다면 실제 코드에서 어떻게 라우팅을 구현하게 될까요?  
  
``` js
// Router.js 
import React from 'react'; import { BrowserRouter, Routes, Route } from 'react-router-dom'; 
import Login from './pages/Login/Login';
import Signup from './pages/Signup/Signup';   
import Main from './pages/Main/Main';      

const Router = () => {   

	return (    
	<BrowserRouter>     
		 <Routes>       
		  <Route path='/' element={<Login />} />     
		  <Route path='/signup' element={<Signup />} >
	      <Route path='/main' element={<Main />} />              
	     </Routes>   
	 </BrowserRouter> ); }; 
	 
	 export default Router;
```


1.  Route 컴포넌트의 path 속성에 따라 화면에 그려줄 UI를 담은 컴포넌트를 import 합니다.
2.  Route 컴포넌트의 path 속성을 설정해 주고, 설정한 경로(url)로 이동했을 때, 화면에 그려질 UI를 담은 컴포넌트를 element 속성에 설정합니다.

그렇다면 http://localhost:3000이라는 주소를 기준으로 했을 때, url이 http://localhost:3000 이면 **Login 컴포넌트**의 내용을 화면에 그려주고, url이 http://localhost:3000/signup일 때는 **Signup 컴포넌트**의 내용을 화면에 그려주게 됩니다.  
  
그런데 Route 컴포넌트의 path 속성에 설정한 경로는 '/' 인데, 왜 아무 경로도 설정하지 않은 http://localhost:3000에서 Login 컴포넌트의 내용을 그려준 것일까요?  
  
왜냐하면 '/' 는 디폴트 값으로 경로가 지정되지 않은 경우와 같기 때문에, url에서 아무런 경로를 지정해 주지 않은 경우에는 Route 컴포넌트의 path 속성에서 ‘/’을 찾아 일치하는 element의 컴포넌트를 그려주게 됩니다.  
  

### 3-2-4. Router 컴포넌트 활용

지금까지 우리는 Router 컴포넌트를 활용해 라우팅을 구현하는 방법에 대해 알아봤습니다. 하지만 Router 컴포넌트도 하나의 컴포넌트이기 때문에 render가 되면 url에 따라서 보여줄 내용물만 찾아서 화면에 그려주게 됩니다. 그렇다면 **경로에 상관없이 모든 화면에서 표시되어야 하는 컴포넌트**가 있다면 어떻게 할 수 있을까요?  
  
![[스크린샷 2022-08-01 오전 9.58.00.png]]


이전에 Routes 컴포넌트는 여러 Route를 감싸서 그중 규칙이 일치하는 라우트 단 하나만을 렌더링 시켜준다고 했습니다. ==그렇다면 경로에 상관없이 보여주고 싶은 컴포넌트가 있다면 위와 같이 이 규칙에 포함되지 않도록 Routes 컴포넌트 밖에 위치시켜주면 됩니다==. 이렇게 구현하게 되면 결과적으로 Nav와 Footer 컴포넌트는 특정 경로에 따라 보여지는 것이 아니라 ==어떤 경로가 오더라도 항상 화면에 보여지게 됩니다.==

## 3-3. index.js 수정하기
``` js
// index.js
import React from 'react'; import ReactDOM from 'react-dom/client'; import Router from './Router';

const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Router />);

```

Router 컴포넌트를 구현했지만, Router 컴포넌트를 화면에 그려주기 위한 마지막 단계가 남아있습니다. 바로 index.js에서 App 컴포넌트가 있는 위치에 Router 컴포넌트를 대체해 주는 것입니다.  
  
이후 잘 적용이 됐는지 확인해 보려면, npm start를 통해 화면을 띄우고 Router 컴포넌트에서 설정해 주었던 path 값을 직접 url에 입력해서 UI가 변경되는 것을 확인하시면 됩니다.  
  
예를 들어, http://localhost:3000을 기준으로 http://localhost:3000/signup을 url에 쓰게 되면 Signup 컴포넌트가 화면에 그려지고, http://localhost:3000/main을 쓰게 되면 Main 컴포넌트가 화면에 그려지게 됩니다.

## 3-4. Route 이동하기

웹 페이지를 사용하다 보면 내가 원하는 페이지로 버튼을 눌러서 이동하는 경우와 같이 특정 동작을 통해 페이지 이동을 하는 경우를 많이 봤을 겁니다. 지금까지 우리는 페이지 이동을 위한 Router 컴포넌트를 구성하고, 그것을 확인하기 위해 매번 직접 url 값을 수정해 줘야 했습니다. 만약 다른 웹 페이지들처럼 특정 동작을 통해 라우팅을 구현하려면 어떻게 해야 할까요? 지금부터는 이러한 경우 어떻게 라우팅을 구현할 수 있는지 알아보겠습니다.  
  

### 3-4-1. Link 컴포넌트 사용하기

첫 번째 방법은 Link 컴포넌트를 사용하는 방법입니다.  
  
```js
// Login.js 
import React from 'react'; 
import { Link } from 'react-router-dom'; 

const Login = () => {   
	return <Link to="/signup">회원가입</Link>;
}; 
	 
export default Login;
```


react-router-dom에서 제공하는 컴포넌트 중 ==Link 컴포넌트를 이용해 라우팅 기능을 구현==할 수 있습니다. Router에서 여러 컴포넌트를 import해서 사용했던 것과 마찬가지로, react-router-dom으로부터 Link 컴포넌트를 import해서 JSX 내부의 원하는 곳에 사용할 수 있습니다.  
  
Link 컴포넌트의 형식을 보면 to 라는 속성에 '/signup'이라는 경로가 적혀 있는 것을 볼 수 있습니다. 이를 통해 화면에서 회원가입이라는 글을 클릭하게 되면 '/signup'이라는 경로로 이동하게 되고, **Route 컴포넌트의 path 값 중 일치하는 경로**를 찾아 해당 컴포넌트를 화면에 그려주게 됩니다.



[그림 3-2] Link 컴포넌트가 실제 페이지에서 a 태그로 그려지는 화면  
  
위와 같이 구현된 화면을 봤을 때, 회원가입이라는 링크를 클릭하면 signup 페이지로 이동하는 것을 확인할 수 있습니다. 그런데 개발자도구를 통해 Link 컴포넌트로 구현한 곳을 살펴보면 a 태그로 변해있는 것을 볼 수 있습니다. 이는 즉, **Link 컴포넌트는 a 태그로 변환되는 것**을 확인할 수 있습니다. 그렇다면 a 태그를 처음부터 사용하면 될 텐데, 왜 Link 컴포넌트를 사용하는 것일까요?  ==(Link 태크는 a로 변환된다!!)==
  
==a 태그를 직접 사용할 경우 페이지 이동 시 서버로부터 매번 **새로운 페이지를 요청**해서 받아오게 됩니다==. 그렇다면, 현재 화면에서 몇 가지만 바뀌어서 렌더링 되어야 하는 작업에서도 전체 화면을 매번 다시 렌더링하기 때문에 **비효율적으로 동작**하게 됩니다.  
  
반면, ==Link 컴포넌트==를 통해 변환된 a 태그는 실제 서버에 요청을 보내지 않고, ==단지 url만 변경==됩니다. 그래서 ==**url의 변경**을 react-router-dom이 인지==하고, **실제 화면에서 바뀌어야 하는 부분만 새로 렌더링**되기 때문에 a 태그를 직접 사용하는 것보다 효율적입니다.  
  
그렇다고 **a 태그를 절대 사용하지 않아야 하는 건 아닙니다. ==a를 사용해야할 때==애플리케이션 내부에서 url을 통해 페이지를 전환해야 할 때**는 Link 컴포넌트를 이용해 효율적으로 이동할 수 있지만, **외부 사이트로 이동할 때**는 항상 전체 페이지를 새로 받아와야 하기 때문에 a tag를 사용해야 합니다. 예를 들어, 아래 사진과 같이 페이지 안에서 instagram이나 blog로 이동해야 하는 경우에는 a 태그를 사용해야 합니다.
![[스크린샷 2022-08-01 오후 1.19.34.png]]

[그림 3-3] 웹 페이지에서 a 태그를 사용하는 경우 예시 이미지 (출처 : wecode 랜딩 페이지)  
  

### 3-4-2. useNavigate hook 사용하기

react-router-dom에는 Link 컴포넌트 외에도 라우팅을 구현할 수 있게 해주는 hook이 있습니다. 여기서 hook은 함수 컴포넌트에서 다루지 못했던 기능들을 구현할 수 있게 도와주는 함수입니다. React에서 자체적으로 제공하는 hook도 있지만, 이번에는 react-router-dom에서 제공하는 useNavigate hook에 대해서 어떻게 사용하는지 알아보도록 하겠습니다.  



![[스크린샷 2022-08-01 오후 1.21.41.png]]

위의 예시는 로그인 버튼을 눌렀을 때 메인페이지로 이동하는 코드입니다.

1.  Link 컴포넌트를 사용했던 것과 마찬가지로 ==react-router-dom에서 useNavigate==를 import 합니다.
2.  useNavigate 함수를 실행하고, 해당 함수가 반환한 결과를 navigate라는 변수에 할당합니다. 여기서 useNavigate가 반환하는 값은 페이지를 이동하는 함수이기 때문에, 결국 navigate 변수는 페이지를 이동하는 함수가 됩니다.
3.  버튼을 눌러서 페이지를 이동하는 로직을 구현해야 하기 때문에 로그인 버튼에서 클릭 이벤트가 발생 시 호출할 함수를 만들어줍니다. 해당 함수 안에서는 navigate 함수가 호출되도록 하고, 인자에는 이동할 경로를 넣어줍니다. 위의 코드를 예시로 들면 클릭 이벤트가 발생했을 때 goToMain이라는 함수를 호출하고 함수 내부에서 navigate('/main')을 호출하면서 Main 페이지로 이동하는 로직입니다.
4.  button 태그에 onClick 이벤트를 생성하고 이벤트 발생 시 실행될 함수를 넣어줍니다. 기존에는 자바스크립트에서 DOM에 직접 접근하고, addEventListner를 이용해 이벤트를 적용했다면, ==React에서는 **JSX의 특징** 이용해서 이벤트를 걸어주고 싶은 태그에 속성을 설정하듯 직접 적용할 수 있습니다.==

그렇다면 여기서 이전에 배웠던 Link 컴포넌트와 useNavigate hook을 비교해 보겠습니다.

==중요!!! link와 useNavigate hook 비교==

==useNavigate 사용하는 이유==

단순히 구현된 로직만 봤을 때 useNavigate hook을 활용하는 방법이 더 복잡한데 왜 useNavigate hook을 사용하는 걸까요? 만약 로그인 버튼을 눌렀을 때 무조건 메인 화면으로 이동하는 것이 아니라, 로그인에 ==성공했을 때만 메인 페이지로 이동하고, 실패==했을 때는 회원가입 페이지로 이동해야 한다면 과연 Link 컴포넌트만으로 구현할 수 있을까요?

Link 컴포넌트는 to 속성을 통해 무조건 해당 url로 이동하게끔 해주기 때문에 위와 같은 예시에 대응할 수 없습니다. 하지만 useNavigate hook을 사용하다면 아래와 같이 사용할 수 있습니다.  
  
``` js
// 실제 활용 예시

const goToMain = () => { 
if (response.message === "valid user") {    
	navigate("/main"); 
} else {  
	alert("가입된 회원이 아닙니다. 회원가입을 먼저 해주세요.");    
    navigate("/signup");  } };
    
```


위 예시를 보면, goToMain 함수가 호출되었을 때 무조건 경로가 바뀌는 것이 아닌 response.messaage를 통해 해당 값이 ‘valid user’이면 메인페이지로 이동하고, 아닌 경우에는 가입된 회원이 아니라고 가정하고 alert창과 함께 회원가입 페이지로 이동시킵니다. 이와 같이 ==navigate는 **함수의 호출 형태로 경로 이동**==을 하기 때문에 코드상에서 조건에 따라 인자를 다르게 부여해 다른 경로로 이동할 수도 있고, 호출 자체를 안할 수도 있습니다. ==결국, 로직에 포함되어 특정 조건에서 경로를 이동하게 하고 싶을 때는 Link 컴포넌트가 아닌 useNavigate hook을 사용하면 됩니다.==  
  

### 3-4-3. 정리

1.  Link 컴포넌트
    -   클릭 시 바로 ==페이지를 이동하기 때문에, 조건 없이 페이지==를 이동할 때 적합합니다.
    -   Nav Bar의 메뉴 혹은 Aside Menu 등 바로 페이지를 이동하는 경우 사용하는 것이 좋습니다.
2.  useNavigate hook
    -   ==조건에 따라 페이지를 전환해야 할 때 사용하기 적합==합니다.
    -   로그인 버튼 클릭 시에 ==백엔드 API로 데이터를 전송하는 작업을 한 뒤 페이지를 이동하거나 userData의 인증 혹은 인가가 필요한 경우, 혹은 로그인 작업 이후 응답 메시지에 따른 분기 처리를 해야 하는 상황일 때, useNavigate를 사용하는 것이 좋습니다.==  
          
        

# 4. Summary

---

-   ==Routing은 다른 경로(url 주소)에 따라 다른 View(화면)를 보여주는 것==입니다. html 파일이 여러 개인 경우 경로에 따라 다른 html 페이지를 보여주는 방식으로 라우팅을 구현했지만, SPA인 웹 애플리케이션에서는 다른 방법으로 라우팅을 구현해야 합니다.
-   r==eact-router-dom은 React에서 라우팅 기능을 구현할 수 있도록 도와주는 패키지==입니다. 패키지 안에 있는 컴포넌트를 이용해 Router 컴포넌트를 구성할 수 있습니다.
-   **어떤 동작에 의해 라우팅 기능을 구현하는 방법**으로는 Link 컴포넌트를 이용하거나 useNavigate hook을 사용하는 방법이 있는데, 상황에 따라서 적합한 방법을 사용해야 합니다.
# 학습 목표
## git flow

## rebase

## squash


# 💁🏻‍♂️ 멘토 가이드

-   2차 프로젝트에서는 `git merge` 명령어를 `git rebase` 명령어로 대체하게 됩니다. 두 방식을 혼용하게 되면 문제가 생길 수 있으니 꼭, 반드시 후자의 방법으로 브랜치를 병합해주세요!
-   `rebase`를 하면서 동시에 `squash` 를 사용해 커밋을 하나로 정리 할 수 있습니다. 꼭 브랜치를 합쳐야 하는 상황이 아니더라도 `git rebase -i main` 명령어를 통해 중간 중간 브랜치에 쌓인 커밋을 하나로 정리해주세요. 또한 정상적인 경우 PR / 브랜치 당 커밋이 하나여야 한다는 점 기억해주세요!
-   `rebase` 도중 충돌이 일어날 경우 마치 코드가 날아간 것 처럼 보일 수 있습니다. 코드가 사라진 것이 아니라 코드를 합치던 도중 중단된 것입니다. 충돌을 해결하고 남은 과정을 끝까지 진행하면 모든 코드가 다 들어와 있게 됩니다. 혹 잘못 리베이스를 했다면, `git rebase —-abort` (리베이스 도중) 혹은 `git reflog` 로 돌아갈 지점을 찾은 후 `git reset --hard 돌아갈지점` (리베이스 완료 후) 명령어로 복구할 수 있습니다.
-   충돌 발생 시 에디터에서 충돌 해결 후 `git add .` → `git rebase -—continue` 를 반복하되, commit을 해줄 필요는 없습니다.


## 기능들이 merge했을떄 사라지는 기능들을 보완할 수 있는 방법

main에서 feature을 바로 팠을때는 merge가 됐을때 사라지는 기능들을 사용자에게 다 보일 수 있다. 그래서 main 브랜치에서 develop 브랜치 를 만들고 이 안에서 feature을 판다.


## merge와  rebase
병합이 완료된 브랜치를 내 브랜치에 병합할때 사용하는 명령어

### Merge와 rebase완전 다른 방식 

머지했을때 사이사이로 시간 순으로 commit이 생겨서 보기 어려워진다.
-> merge 사용하면 commit이 시간순으로 입력이 되고 history를 파악하기 어려워진다. 

**브랜치는 의미있는 기능 단위로 만드는 것.**


### 문제점 



### rebase으로 인해 merge  문제 해결
1. 불필요한 머지 커밋 x
2. 히스토리 이력을 확인하기가 용이하다 
3. 고유 번호가 달라진다? -> 기존의 커밋을 토대로 base를 뒤로 바꿔서 새로운 커밋을 똑같이 만들어주는 것. 
4. 마지막 커밋에 베이스를 옮겨주는 것!!->  ==동작원리== 


### 하지만 rebase는 commit 갯수 만틈 conflict가 날 수 있다.

conflict는 commit 과 commit 사이에엇 일어나는 작업 내용 사이의 충돌이 므로 세개의 커밋이 한번에 충돌 날 가능성이 있다.


### 여기서 rebase를 제대로 사용하려면 git rebase -i main을 사용해야한다? 


메인에 새로운 작업물들이 들어오고 그것을 토대로 병합하려고 할떄 conflict가 발생하는 것이었는데 
아예 새로운 작업물 받기 이전에 자신의 main 에 합치고 여러개 커밋을 하나로 합치고 다시 메인브랜치로 이동해서 최신화하고 그것을 rebase를 진행하면 컴플릭트 한번만 해결하면 된다?



# 처음 squash 해봄




